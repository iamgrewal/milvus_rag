---
description: Provides comprehensive guidelines for using the secure_config library, covering security, performance, and coding standards. This guide aims to ensure secure and efficient configuration management in Python projects.
globs: **/*.py
---
# secure_config Best Practices

This document outlines the best practices for using the `secure_config` library in Python projects. Following these guidelines will help you manage configurations securely and efficiently, prevent common pitfalls, and adhere to coding standards.

## Library Information:

- Name: secure_config
- Tags: security, fernet, encryption, env, secrets, configuration, api-keys

## 1. Code Organization and Structure

### 1.1. Modular Design

-   **Principle:** Organize your code into modular components. Separate concerns to improve maintainability and testability.
-   **Implementation:**
    -   Create dedicated modules for configuration loading, key management, and encryption/decryption operations.
    -   Use classes to encapsulate related functionality.

python
# Example of modular code structure

# config_loader.py
from secureconfig import SecureConfigParser, EnvCryptKeeper
import os

class ConfigLoader:
    def __init__(self, config_file, key_env_var):
        self.config_file = config_file
        self.key_env_var = key_env_var
        self.config = None

    def load_config(self):
        try:
            key = os.environ[self.key_env_var]
            ck = EnvCryptKeeper(key)
            self.config = SecureConfigParser(ck)
            self.config.read(self.config_file)
            return self.config
        except KeyError:
            print(f"Environment variable '{self.key_env_var}' not set.")
            return None


# main.py
from config_loader import ConfigLoader

config_loader = ConfigLoader('config.ini', 'MY_SECRET_KEY')
config = config_loader.load_config()

if config:
    username = config.get('database', 'username')
    print(f'Username: {username}')


### 1.2. Directory Structure

-   **Recommendation:** Maintain a clear directory structure for your project.
-   **Example:**

    
    project/
    ├── config/
    │   ├── config.ini          # Configuration file
    │   └── config_schema.json   # Schema for validation (optional)
    ├── src/
    │   ├── __init__.py
    │   ├── config_loader.py   # Module for loading configurations
    │   └── ...
    ├── tests/
    │   ├── __init__.py
    │   └── test_config.py     # Tests for configuration loading
    ├── .env                 # Environment variables (for development)
    ├── pyproject.toml         # Project metadata and dependencies
    └── README.md
    

## 2. Common Patterns and Anti-patterns

### 2.1. Configuration Loading Pattern

-   **Pattern:** Use a dedicated function or class to load configurations.
-   **Benefits:** Centralizes configuration logic, making it easier to manage and test.

python
# Recommended Pattern
from secureconfig import SecureConfigParser
import os

class Config:
    def __init__(self, config_file, key_env_var):
        self.config_file = config_file
        self.key_env_var = key_env_var
        self.parser = None

    def load(self):
        try:
            key = os.environ[self.key_env_var]
            self.parser = SecureConfigParser.from_env(self.key_env_var)
            self.parser.read(self.config_file)
        except KeyError as e:
            print(f'Error: {e}')

    def get(self, section, key):
        return self.parser.get(section, key)

# Usage
config = Config('config.ini', 'MY_SECRET_KEY')
config.load()
username = config.get('database', 'username')


### 2.2. Anti-pattern: Hardcoding Secrets

-   **Anti-pattern:** Embedding secrets directly in the code.
-   **Risk:** Exposes secrets in version control and increases the risk of unauthorized access.

python
# Avoid:
DATABASE_PASSWORD = "P@sswOrd123"  # Hardcoded secret

# Prefer:
import os
DATABASE_PASSWORD = os.environ.get("DATABASE_PASSWORD")  # Use environment variables


### 2.3. Anti-pattern: Committing Configuration Files with Secrets

-   **Anti-pattern:** Including configuration files with plain text secrets in the repository.
-   **Risk:** Exposes secrets to anyone with access to the repository.
-   **Mitigation:**
    -   Encrypt sensitive data in configuration files using `secureconfig`.
    -   Use `.gitignore` to exclude configuration files containing secrets.

## 3. Performance Considerations

### 3.1. Key Management

-   **Recommendation:** Store Fernet keys securely using environment variables or secret managers like AWS Secrets Manager or HashiCorp Vault.
-   **Rationale:** Prevents keys from being exposed in the codebase.

### 3.2. Encryption Overhead

-   **Consideration:** Encryption and decryption operations can introduce overhead.
-   **Optimization:**
    -   Cache decrypted configuration values to reduce the frequency of decryption.
    -   Avoid encrypting large configuration files unnecessarily.

### 3.3. Lazy Loading

-   **Recommendation:** Load configurations only when needed.
-   **Rationale:** Reduces startup time and resource consumption.

python
# Lazy loading example
class MyService:
    def __init__(self):
        self._config = None

    def get_config(self):
        if self._config is None:
            self._config = self._load_config()
        return self._config

    def _load_config(self):
        # Load configuration here
        pass


## 4. Security Best Practices

### 4.1. Key Rotation

-   **Recommendation:** Regularly rotate encryption keys.
-   **Rationale:** Limits the impact of a compromised key.

### 4.2. Secure Key Storage

-   **Recommendation:** Store encryption keys securely.
-   **Implementation:**
    -   Use environment variables.
    -   Use secret managers like AWS Secrets Manager, HashiCorp Vault, or Doppler.
    -   Ensure proper access controls are in place.

### 4.3. Input Validation

-   **Recommendation:** Validate configuration values.
-   **Rationale:** Prevents injection attacks and ensures data integrity.

python
# Input validation example
def validate_config(config):
    # Validate username
    username = config.get('database', 'username')
    if not isinstance(username, str) or len(username) < 3:
        raise ValueError("Invalid username")

    # Validate port
    port = int(config.get('database', 'port'))
    if not 1024 <= port <= 65535:
        raise ValueError("Invalid port")

# Usage
try:
    validate_config(config)
except ValueError as e:
    print(f"Configuration error: {e}")


### 4.4. Principle of Least Privilege

-   **Recommendation:** Grant only necessary permissions to access configuration data.
-   **Rationale:** Minimizes the potential damage from compromised accounts.

### 4.5. Dependency Management

-   **Recommendation:** Use virtual environments to isolate dependencies.
-   **Implementation:**
    -   Use `venv` or `pipenv` to create isolated environments.
    -   Regularly update dependencies with `pip list --outdated` and `pip install --upgrade`.
    -   Use trusted package sources and consider package signing with PEP 668 and tools like Sigstore.
    -   Scan dependencies for vulnerabilities with tools like `pip-audit`, Safety, or OWASP Dependency-Check.

### 4.6. Encryption in Transit and at Rest

-   **Recommendation:** Encrypt sensitive data both at rest (in configuration files) and in transit (when accessed over a network).
-   **Implementation:**
    -   Use Fernet for symmetric encryption.
    -   Use TLS 1.3 for secure data transmission.

### 4.7. Logging and Monitoring

-   **Recommendation:** Implement structured logging and monitor configuration access.
-   **Rationale:** Helps detect and respond to security incidents.

python
# Logging example
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Log configuration access
logger.info(f"User accessed configuration value: {config.get('section', 'key')}")

# Avoid logging sensitive data
# logger.info(f"Password: {password}")  # Avoid logging passwords!


### 4.8. Secure Cookies

-   **Recommendation:** When using configurations related to web applications, ensure secure cookie attributes are set.
-   **Implementation:**
    -   Set `Secure`, `HttpOnly`, and `SameSite=Strict` attributes for cookies.

### 4.9. CSRF Protection

-   **Recommendation:** Mitigate Cross-Site Request Forgery (CSRF) attacks.
-   **Implementation:**
    -   Use proper tokens (e.g., `csrf_token`).

### 4.10. CORS Restriction

-   **Recommendation:** Limit CORS to trusted domains.
-   **Implementation:**
    -   Use libraries like `Flask-CORS` or Django's `CORS_ALLOW_ORIGIN`.

### 4.11. Avoid Logging Sensitive Data

-   **Recommendation:** Mask API keys, tokens, and passwords in logs.
-   **Implementation:**
    -   Use structured logging with tools like `structlog` or `logging.JSONFormatter`.

### 4.12. Container Security

-   **Recommendation:** Use container security best practices.
-   **Implementation:**
    -   Scan container images for vulnerabilities using tools like Docker Scan, Trivy, or Grype.
    -   Use minimal base images (e.g., `python:slim`).

### 4.13. AI/ML Security Considerations

-   **Recommendation:** Protect AI models against data poisoning and adversarial attacks.
-   **Implementation:**
    -   Use model watermarking and differential privacy for ML security.
    -   Verify model integrity with hashing and secure model signing.

### 4.14. Supply Chain Security

-   **Recommendation:** Verify package integrity.
-   **Implementation:**
    -   Use PEP 458 (secure PyPI signing).
    -   Use SBOMs (Software Bill of Materials) with tools like Syft to track dependencies.
    -   Scan for malicious Python packages using tools like Checkmarx’s Malicious Package Detector.

### 4.15. Compliance and Governance

-   **Recommendation:** Follow security standards like ISO 27001, SOC 2, NIST, OWASP Top 10.
-   **Implementation:**
    -   Regularly perform penetration testing and red team exercises.
    -   Implement Zero Trust Architecture (ZTA) principles in cloud environments.
    - Automate security testing in CI/CD pipelines with Bandit, Snyk, and Semgrep.

## 5. Testing Approaches

### 5.1. Unit Tests

-   **Recommendation:** Write unit tests to verify configuration loading and decryption.
-   **Example:**

python
# tests/test_config.py
import unittest
from secureconfig import SecureConfigParser
import os

class TestConfig(unittest.TestCase):
    def setUp(self):
        os.environ['TEST_KEY'] = 'test_key'
        self.config = SecureConfigParser.from_env('TEST_KEY')
        self.config.read_string("[test_section]\nvalue = ENC(encrypted_value)")

    def test_config_loading(self):
        self.assertIsNotNone(self.config)

    def test_config_decryption(self):
        # Mock decryption
        self.config.ck.decrypt = lambda x: x.replace('ENC(', '').replace(')', '')
        value = self.config.get('test_section', 'value')
        self.assertEqual(value, 'encrypted_value')

if __name__ == '__main__':
    unittest.main()


### 5.2. Integration Tests

-   **Recommendation:** Test the integration of configuration loading with other components.
-   **Example:** Verify that the application behaves correctly with the loaded configuration.

### 5.3. End-to-End Tests

-   **Recommendation:** Perform end-to-end tests to ensure that the entire system works as expected with the configuration.

### 5.4. Mocking and Patching

-   **Recommendation:** Use mocking and patching to isolate configuration loading during testing.
-   **Rationale:** Allows you to test different configuration scenarios without relying on external resources.

## 6. Common Pitfalls and Gotchas

### 6.1. Incorrect Key Management

-   **Pitfall:** Mishandling encryption keys.
-   **Prevention:** Follow secure key storage and rotation practices.

### 6.2. Improper Error Handling

-   **Pitfall:** Failing to handle configuration loading errors.
-   **Prevention:** Implement proper error handling to gracefully handle missing or invalid configurations.

### 6.3. Not Updating Dependencies

-   **Pitfall:** Using outdated dependencies with known vulnerabilities.
-   **Prevention:** Regularly update dependencies and monitor for security advisories.

### 6.4. Side-Channel Attacks

-   **Pitfall:** Vulnerability to timing attacks or other side-channel exploits due to improper cryptographic implementations.
-   **Prevention:** Use established, well-vetted cryptographic libraries like cryptography and follow their recommended usage patterns to avoid subtle implementation flaws.

### 6.5. Insecure Random Number Generation

-   **Pitfall:** Using weak or predictable random number generators for key creation or other security-sensitive operations.
-   **Prevention:** Always use the `os.urandom()` function or the `secrets` module for generating cryptographically secure random numbers.

## 7. Tooling and Environment

### 7.1. Virtual Environments

-   **Tool:** `venv`, `pipenv`
-   **Usage:** Create isolated environments for each project.

### 7.2. Secret Managers

-   **Tools:** AWS Secrets Manager, HashiCorp Vault, Doppler
-   **Usage:** Store and manage encryption keys securely.

### 7.3. Security Scanners

-   **Tools:** Bandit, Snyk, Semgrep, Trivy, Grype, pip-audit, Safety, OWASP Dependency-Check
-   **Usage:** Scan code and dependencies for vulnerabilities.

### 7.4. CI/CD Integration

-   **Tool:** GitHub Actions, GitLab CI, Jenkins
-   **Usage:** Automate security testing in CI/CD pipelines.

### 7.5. Linters and Static Analyzers

-   **Tools:** `mypy`, `pylint`, `flake8`
-   **Usage:** Catch issues early and enforce coding standards.

By adhering to these best practices, you can effectively leverage the `secure_config` library to enhance the security and maintainability of your Python projects.