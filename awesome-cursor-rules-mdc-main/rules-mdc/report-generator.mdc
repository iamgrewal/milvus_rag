---
description: This rule provides guidelines and best practices for developing and maintaining the report-generator library, covering aspects like code structure, performance, security, and testing. It aims to ensure code quality, maintainability, and reliability.
globs: **/*.{rmd,md,Rmd,markdown,Rmarkdown}
---
# report-generator Best Practices

This document outlines best practices for developing and maintaining the `report-generator` library. Adhering to these guidelines will ensure code quality, maintainability, and reliability.

## 1. Code Organization and Structure

### 1.1. Directory Structure

-   **`src/`**: Contains the core source code of the library.
    -   `report_generator.py` or `report_generator.R`: Main file containing the primary functions and classes.
    -   `modules/`: Subdirectories for organizing related functionalities into modules (e.g., `markdown_parser/`, `pdf_exporter/`).
-   **`tests/`**: Contains unit and integration tests.
    -   `test_report_generator.py` or `test_report_generator.R`: Test file for the main functionality.
    -   `test_modules/`: Subdirectories mirroring the `modules/` directory for testing individual modules.
-   **`docs/`**: Contains documentation files.
    -   `README.md`: Project overview and usage instructions.
    -   `API.md`: Detailed API documentation.
    -   `user_guide.md`: User-friendly guide with examples.
-   **`examples/`**: Example reports and code snippets demonstrating library usage.
-   `.cursor/rules/`: Contains Cursor rules for the project.
-   **`data/`**: Sample data files for testing and examples (optional).
-   **`scripts/`**: Utility scripts for tasks like building documentation or running tests.
-   **`.gitignore`**: Specifies intentionally untracked files that Git should ignore.
-   **`LICENSE`**: License information for the library.
-   **`Makefile`** or **`requirements.txt`** or **`DESCRIPTION`**: Build and dependency management.

### 1.2. Module Design

-   **Single Responsibility Principle (SRP)**: Each module should have a single, well-defined purpose.
-   **Loose Coupling**: Modules should be as independent as possible to minimize dependencies and improve maintainability.
-   **Clear Interfaces**: Define clear and consistent interfaces for interacting with modules.
-   **Well-Documented Code**: All functions, classes, and modules must be thoroughly documented with docstrings or comments explaining their purpose, parameters, and return values.

### 1.3. Code Style

-   **Consistent Naming Conventions**: Use descriptive and consistent naming conventions for variables, functions, and classes (e.g., `snake_case` in Python, `camelCase` in JavaScript).  Follow language-specific conventions.
-   **Meaningful Variable Names**:  Avoid single-character variable names except for loop counters. Use names that clearly indicate the variable's purpose.
-   **Code Comments**:  Add comments to explain complex logic, algorithms, or non-obvious code sections.  Keep comments concise and up-to-date.
-   **Line Length**:  Limit line length to a reasonable number of characters (e.g., 79 characters in Python, 120 in R) for readability.
-   **Whitespace**: Use whitespace to improve readability (e.g., around operators, after commas, and between logical blocks of code).
-   **Linting**:  Use a linter (e.g., `flake8` or `pylint` in Python, `lintr` in R) to automatically enforce code style and identify potential errors.

## 2. Common Patterns and Anti-patterns

### 2.1. Common Patterns

-   **Template Method Pattern**: Define a template for report generation with customizable steps.
-   **Strategy Pattern**: Implement different export strategies (e.g., PDF, Markdown) using a common interface.
-   **Factory Pattern**:  Use a factory function to create report objects based on configuration or input data.
-   **Observer Pattern**: Implement event handling for report generation progress or errors.

### 2.2. Anti-patterns

-   **God Class**: Avoid creating classes that are too large and handle too many responsibilities.
-   **Spaghetti Code**: Avoid complex, unstructured code that is difficult to understand and maintain.
-   **Copy-Paste Programming**:  Avoid duplicating code. Extract common logic into reusable functions or classes.
-   **Magic Numbers**:  Avoid using hardcoded numerical values without explanation.  Use named constants instead.
-   **Ignoring Errors**: Always handle potential errors and exceptions gracefully.  Don't simply ignore them.

## 3. Performance Considerations

### 3.1. Data Handling

-   **Efficient Data Structures**: Use appropriate data structures (e.g., dictionaries, sets, data frames) for efficient data storage and retrieval.
-   **Lazy Loading**: Load data only when needed to minimize memory usage and startup time.
-   **Data Caching**: Cache frequently accessed data to reduce the need for repeated computations or I/O operations.
-   **Data Streaming**: Process large datasets in chunks or streams to avoid loading the entire dataset into memory at once.

### 3.2. Algorithm Optimization

-   **Profiling**: Use profiling tools to identify performance bottlenecks in the code.
-   **Algorithm Choice**:  Select algorithms with appropriate time and space complexity for the task.
-   **Vectorization**: Utilize vectorized operations (e.g., NumPy in Python, base R functions) to perform computations efficiently on entire arrays or data structures rather than looping through individual elements.
-   **Parallelization**:  Use parallel processing or multithreading to speed up computationally intensive tasks.

### 3.3. I/O Optimization

-   **File Format**: Choose efficient file formats (e.g., CSV, Feather, Parquet) for reading and writing data.
-   **Buffering**: Use buffered I/O to reduce the number of disk access operations.
-   **Compression**:  Compress data files to reduce storage space and I/O bandwidth.

## 4. Security Best Practices

### 4.1. Input Validation

-   **Sanitize Inputs**: Sanitize all user inputs to prevent injection attacks (e.g., SQL injection, cross-site scripting).
-   **Validate Data Types**: Validate that input data conforms to the expected data types and formats.
-   **Limit Input Length**:  Limit the length of input strings to prevent buffer overflows or denial-of-service attacks.

### 4.2. Secure Configuration

-   **Avoid Hardcoding Secrets**:  Never hardcode sensitive information (e.g., passwords, API keys) in the code.  Use environment variables or configuration files to store them securely.
-   **Restrict Permissions**:  Grant the library only the minimum necessary permissions to access files, databases, or other resources.
-   **Secure File Handling**: Implement proper file handling procedures to prevent unauthorized access or modification of files.

### 4.3. Dependency Management

-   **Keep Dependencies Up-to-Date**: Regularly update dependencies to patch security vulnerabilities.
-   **Use Dependency Scanning Tools**: Use tools to scan dependencies for known vulnerabilities.
-   **Pin Dependencies**:  Specify exact versions of dependencies to prevent unexpected behavior due to updates.

## 5. Testing Approaches

### 5.1. Unit Testing

-   **Test Individual Components**: Write unit tests to verify the functionality of individual functions, classes, or modules.
-   **Test Edge Cases**: Test edge cases, boundary conditions, and invalid inputs to ensure robustness.
-   **Use Mocking**: Use mocking to isolate components during testing and simulate external dependencies.

### 5.2. Integration Testing

-   **Test Interactions Between Components**: Write integration tests to verify the interactions between different components of the library.
-   **Test Data Flows**:  Test the flow of data through the library to ensure that data is processed correctly at each stage.

### 5.3. End-to-End Testing

-   **Test Complete Workflows**: Write end-to-end tests to verify complete report generation workflows from start to finish.
-   **Test Different Output Formats**: Test the generation of reports in different output formats (e.g., PDF, Markdown) to ensure consistency and accuracy.

### 5.4 Test-Driven Development (TDD)

-   Consider Test-Driven Development. Write tests *before* implementing the code. This helps to define requirements more clearly and ensures that the code is testable.

### 5.5 Code Coverage

-   Use code coverage tools to measure the percentage of code that is covered by tests. Aim for high code coverage to ensure that most of the code is tested.

## 6. Common Pitfalls and Gotchas

### 6.1. Dependency Conflicts

-   Be aware of potential dependency conflicts between the library and other packages or libraries in the user's environment.
-   Use virtual environments or containerization to isolate dependencies.

### 6.2. File Encoding Issues

-   Handle file encoding issues correctly, especially when dealing with non-ASCII characters.
-   Specify the encoding when reading and writing files (e.g., `utf-8`).

### 6.3. Platform-Specific Issues

-   Be aware of potential platform-specific issues (e.g., file path differences, system commands).
-   Test the library on different operating systems to ensure cross-platform compatibility.

### 6.4. Memory Management

-   Be mindful of memory usage, especially when processing large datasets.
-   Release resources when they are no longer needed to prevent memory leaks.

### 6.5 Path Handling

- Use `os.path.join` (Python) or its equivalent in other languages to construct file paths to ensure cross-platform compatibility.
- Always validate that file paths exist and are accessible before attempting to read or write to them.

## 7. Tooling and Environment

### 7.1. Development Environment

-   **IDE**: Use an IDE (e.g., VS Code, PyCharm, RStudio) with code completion, debugging, and linting features.
-   **Virtual Environment**: Use a virtual environment (e.g., `venv` in Python, `renv` in R) to isolate project dependencies.

### 7.2. Build Tools

-   **Make**: Use Makefiles to automate build, test, and deployment tasks.
-   **Poetry/Pip (Python)** or **`renv` (R)**: Use dependency management tools to manage project dependencies.

### 7.3. Documentation Tools

-   **Sphinx (Python)** or **Roxygen2 (R)**: Use documentation generators to create API documentation from docstrings or comments.
-   **Markdown**: Use Markdown for writing documentation and user guides.

### 7.4. Testing Tools

-   **pytest (Python)** or **testthat (R)**: Use testing frameworks for writing and running unit and integration tests.
-   **Coverage.py (Python)** or **covr (R)**: Use code coverage tools to measure test coverage.

### 7.5 Version Control

-   **Git**: Use Git for version control and collaboration.
-   **GitHub/GitLab/Bitbucket**: Use a Git hosting service for remote repository management and collaboration.

### 7.6 Continuous Integration (CI)

-   **GitHub Actions/GitLab CI/Jenkins**: Use a CI system to automatically run tests and linters on every code change.

By following these best practices, the `report-generator` library can be developed and maintained in a way that ensures code quality, maintainability, and reliability. This will ultimately lead to a better user experience and a more successful project.