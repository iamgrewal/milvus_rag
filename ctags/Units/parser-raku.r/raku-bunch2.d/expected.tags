!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Universal Ctags	//
!_TAG_PROGRAM_URL	https://github.com/universal-ctags/ctags	/official site/
!_TAG_PROGRAM_VERSION	Development	//
BUILD	input.rakumod	/^        submethod BUILD(:&!setup) { }$/;"	b
Channel	input.rakumod	/^    method Channel(Supply:D:) {$/;"	m
OnSupply	input.rakumod	/^    my class OnSupply does Supply {$/;"	c
Promise	input.rakumod	/^    method Promise(Supply:D:) {$/;"	m
Supply	input.rakumod	/^    method Supply(Supply:) { self }$/;"	m
Supply	input.rakumod	/^my role Supply {$/;"	r
SupplyOperations	input.rakumod	/^my class SupplyOperations is repr('Uninstantiable') { ... }$/;"	c
Tap	input.rakumod	/^my class Tap {$/;"	c
X::Supply::Combinator	input.rakumod	/^my class X::Supply::Combinator is Exception {$/;"	c
X::Supply::On::BadSetup	input.rakumod	/^my class X::Supply::On::BadSetup is Exception {$/;"	c
X::Supply::On::NoEmit	input.rakumod	/^my class X::Supply::On::NoEmit is Exception {$/;"	c
act	input.rakumod	/^    method act(Supply:D: &actor) {$/;"	m
add	input.rakumod	/^            sub add ($source, $what, $index?) {$/;"	s
add_source	input.rakumod	/^        method !add_source($/;"	m
batch	input.rakumod	/^    method batch(Supply:D $self: :$elems, :$seconds ) {$/;"	m
categorize	input.rakumod	/^    multi method categorize(Supply:D: %mapper )  {$/;"	m
categorize	input.rakumod	/^    multi method categorize(Supply:D: &mapper )  {$/;"	m
categorize	input.rakumod	/^    multi method categorize(Supply:D: @mapper )  {$/;"	m
categorize	input.rakumod	/^    proto method categorize (|) { * }$/;"	m
classify	input.rakumod	/^    multi method classify(Supply:D: %mapper )  {$/;"	m
classify	input.rakumod	/^    multi method classify(Supply:D: &mapper )  {$/;"	m
classify	input.rakumod	/^    multi method classify(Supply:D: @mapper )  {$/;"	m
close	input.rakumod	/^    method close (Tap:D:) { $!supply.close(self) }$/;"	m
close	input.rakumod	/^    multi method close(Supply:D: Tap $t) {$/;"	m
close	input.rakumod	/^    multi method close(Supply:D:) { self.close($_) for self.tappers }$/;"	m
close	input.rakumod	/^    proto method close(|) { * }$/;"	m
delay	input.rakumod	/^    method delay(Supply:D: $time, :$scheduler = $*SCHEDULER) {$/;"	m
delayed	input.rakumod	/^    method delayed(Supply:D: $time, :$scheduler = $*SCHEDULER) {$/;"	m
do	input.rakumod	/^    method do(Supply:D $self: &side_effect) {$/;"	m
done	input.rakumod	/^        method done() {$/;"	m
done	input.rakumod	/^    method done(Supply:D:) {$/;"	m
elems	input.rakumod	/^    method elems(Supply:D $self: $seconds? ) {$/;"	m
emit	input.rakumod	/^        method emit(\\msg) {$/;"	m
emit	input.rakumod	/^    method emit(Supply:D: \\msg) {$/;"	m
flat	input.rakumod	/^    method flat(Supply:D: )              { SupplyOperations.flat(self) }$/;"	m
flush	input.rakumod	/^                sub flush {$/;"	s
flush	input.rakumod	/^                sub flush() {$/;"	s
for	input.rakumod	/^    method for(Supply:U: |c) {$/;"	m
from-list	input.rakumod	/^    method from-list(Supply:U: |c)       { SupplyOperations.from-list(|c) }$/;"	m
grab	input.rakumod	/^    method grab(Supply:D $self: &when_done) {$/;"	m
grep	input.rakumod	/^    method grep(Supply:D: Mu $test)      { SupplyOperations.grep(self, $test) }$/;"	m
interval	input.rakumod	/^    method interval(Supply:U: |c)        { SupplyOperations.interval(|c) }$/;"	m
last	input.rakumod	/^    method last(Supply:D $self: Int $number = 1) {  # should be Natural$/;"	m
lines	input.rakumod	/^    method lines(Supply:D $self: :$chomp = True ) {$/;"	m
list	input.rakumod	/^    method list(Supply:D:) {$/;"	m
live	input.rakumod	/^        method live { $!live }$/;"	m
live	input.rakumod	/^    method live(Supply:D:) { True };$/;"	m
map	input.rakumod	/^    method map(Supply:D: &mapper)        { SupplyOperations.map(self, &mapper) }$/;"	m
max	input.rakumod	/^    method max(Supply:D $self: &by = &infix:<cmp>) {$/;"	m
merge	input.rakumod	/^    method merge(*@s) {$/;"	m
message	input.rakumod	/^    method message() { "Can only use $!combinator to combine defined Supply objects" }$/;"	m
message	input.rakumod	/^    method message() {$/;"	m
migrate	input.rakumod	/^    method migrate(Supply:D: )           { SupplyOperations.migrate(self) }$/;"	m
min	input.rakumod	/^    method min(Supply:D $self: &by = &infix:<cmp>) {$/;"	m
minmax	input.rakumod	/^    method minmax(Supply:D $self: &by = &infix:<cmp>) {$/;"	m
more	input.rakumod	/^    method more(Supply:D: \\msg) {$/;"	m
next-batch	input.rakumod	/^                sub next-batch() {$/;"	s
on	input.rakumod	/^sub on(&setup) {$/;"	s
on-demand	input.rakumod	/^    method on-demand(Supply:U: |c)       { SupplyOperations.on-demand(|c) }$/;"	m
on_demand	input.rakumod	/^    method on_demand(Supply:U: |c)       {$/;"	m
quit	input.rakumod	/^        method quit($ex) {$/;"	m
quit	input.rakumod	/^    method quit(Supply:D: $ex) {$/;"	m
reduce	input.rakumod	/^    method reduce(Supply:D $self: &with) {$/;"	m
reverse	input.rakumod	/^    method reverse(Supply:D:)                 { self.grab( {.reverse} ) }$/;"	m
rotor	input.rakumod	/^    multi method rotor(Supply:D $self: *@cycle, :$partial) {$/;"	m
rotor	input.rakumod	/^    multi method rotor(Supply:D:) {$/;"	m
rotor	input.rakumod	/^    proto method rotor(|) {*}$/;"	m
schedule-on	input.rakumod	/^    method schedule-on(Supply:D: Scheduler $scheduler) {$/;"	m
schedule_on	input.rakumod	/^    method schedule_on(Supply:D: Scheduler $scheduler) {$/;"	m
sort	input.rakumod	/^    method sort(Supply:D: &by = &infix:<cmp>) { self.grab( {.sort(&by)} ) }$/;"	m
squish	input.rakumod	/^    method squish(Supply:D $self: :&as, :&with is copy) {$/;"	m
stable	input.rakumod	/^    method stable(Supply:D: $time, :$scheduler = $*SCHEDULER) {$/;"	m
start	input.rakumod	/^    method start(Supply:D: &startee)     { SupplyOperations.start(self, &startee) }$/;"	m
tap	input.rakumod	/^        method tap(|c) {$/;"	m
tap	input.rakumod	/^    method tap(Supply:D: &emit = -> $ { }, :&done,:&quit={die $_},:&closing) {$/;"	m
tappers	input.rakumod	/^    method tappers(Supply:D:) {$/;"	m
taps	input.rakumod	/^    method taps(Supply:D:) { +@!tappers }$/;"	m
uniq	input.rakumod	/^    method uniq(Supply:D: |c) {$/;"	m
unique	input.rakumod	/^    method unique(Supply:D $self: :&as, :&with, :$expires) {$/;"	m
wait	input.rakumod	/^    method wait(Supply:D:) {$/;"	m
words	input.rakumod	/^    method words(Supply:D $self:) {$/;"	m
zip	input.rakumod	/^    method zip(*@s, :&with is copy = &[,]) {$/;"	m
zip-latest	input.rakumod	/^    method zip-latest(*@s, :&with is copy = &[,], :$initial ) {$/;"	m
